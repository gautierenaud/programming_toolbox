# tcache

## tcache poisoning

Similarily to fastbin attacks, this exploit revolves around creating a fake memory chunk that will give us write access anywhere.

Following the example from shellphish, let's take a look at the memory layout after the initial frees:
```
gef➤  x/22gx 0x0000555555559290
0x555555559290:	0x0000000000000000	0x0000000000000091  <- first chunk's headers>
0x5555555592a0:	0x0000000000000000	0x0000555555559010
0x5555555592b0:	0x0000000000000000	0x0000000000000000
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000000000
0x5555555592e0:	0x0000000000000000	0x0000000000000000
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000000	0x0000000000000000
0x555555559310:	0x0000000000000000	0x0000000000000000
0x555555559320:	0x0000000000000000	0x0000000000000091  <- second chunk's headers>
0x555555559330:	0x00005555555592a0	0x0000555555559010
```

As we can see, the second chunk is pointing to the first one.

Now supposing we have a way to write over the second chunk, we put the address of the target we want to gain access over in the second chunk:
```
gef➤  x/22gx 0x0000555555559290
0x555555559290:	0x0000000000000000	0x0000000000000091
0x5555555592a0:	0x0000000000000000	0x0000555555559010
0x5555555592b0:	0x0000000000000000	0x0000000000000000
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000000000
0x5555555592e0:	0x0000000000000000	0x0000000000000000
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000000	0x0000000000000000
0x555555559310:	0x0000000000000000	0x0000000000000000
0x555555559320:	0x0000000000000000	0x0000000000000091
0x555555559330:	0x00007fffffffdbd8	0x0000555555559010  <- here we put the address of the target in the fd pointer>
```

We then allocate the second chunk:
```
0x555555559290:	0x0000000000000000	0x0000000000000091
0x5555555592a0:	0x0000000000000000	0x0000555555559010
0x5555555592b0:	0x0000000000000000	0x0000000000000000
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000000000
0x5555555592e0:	0x0000000000000000	0x0000000000000000
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000000	0x0000000000000000
0x555555559310:	0x0000000000000000	0x0000000000000000
0x555555559320:	0x0000000000000000	0x0000000000000091
0x555555559330:	0x00007fffffffdbd8	0x0000000000000000
```

And we see in the tcache list:
```
Tcachebins[idx=7, size=0x90] count=1  ←  Chunk(addr=0x7fffffffdbd8, size=0x7ffff7fadfc8, flags=)  ←  Chunk(addr=0x555555555410, size=0x9066c3c9fffffcc0, flags=NON_MAIN_ARENA)  ←  [Corrupted chunk at 0x8d4c5741fa1e0ff3]
```

There is a chunk at address `0x7fffffffdbd8` (i.e. our target).

So when we allocate it again, we will get a write access to this address.

## tcache stashing

This one seems to require a bit more effort to setup.

First we fillup tcache with 7 chunks + 2 chunks in small bin.
```
gef➤  heap bins
─────────────────────────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7fa8b80 ───────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=8, size=0xa0] count=7  ←  Chunk(addr=0x555555559340, size=0xa0, flags=)  ←  Chunk(addr=0x5555555597a0, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559700, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559660, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x5555555595c0, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559520, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559480, size=0xa0, flags=) 
──────────────────────────────────────────────────────────────────────────────────── Fastbins for arena 0x7ffff7fa8b80 ────────────────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena 'main_arena' ───────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────────────────────── Small Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] small_bins[9]: fw=0x5555555593d0, bk=0x555555559290
 →   Chunk(addr=0x5555555593e0, size=0xa0, flags=PREV_INUSE)   →   Chunk(addr=0x5555555592a0, size=0xa0, flags=PREV_INUSE)
[+] Found 2 chunks in 1 small non-empty bins.
──────────────────────────────────────────────────────────────────────────────────── Large Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```

We then allocate two chunks from tcache:
```
gef➤  heap bins
─────────────────────────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7fa8b80 ───────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=8, size=0xa0] count=5  ←  Chunk(addr=0x555555559700, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559660, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x5555555595c0, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559520, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559480, size=0xa0, flags=) 
──────────────────────────────────────────────────────────────────────────────────── Fastbins for arena 0x7ffff7fa8b80 ────────────────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena 'main_arena' ───────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────────────────────── Small Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] small_bins[9]: fw=0x5555555593d0, bk=0x555555559290
 →   Chunk(addr=0x5555555593e0, size=0xa0, flags=PREV_INUSE)   →   Chunk(addr=0x5555555592a0, size=0xa0, flags=PREV_INUSE)
[+] Found 2 chunks in 1 small non-empty bins.
──────────────────────────────────────────────────────────────────────────────────── Large Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```

We then overwrite the bk pointer of a chunk in smallbin (corresponds to the first one):
```
gef➤  x/4gx 0x00005555555593d0
0x5555555593d0:	0x0000000000000000	0x00000000000000a1
0x5555555593e0:	0x0000555555559290	0x00007fffffffdaf0  <- here we overwrite the bk pointer to our target>
```

The we need a call to `calloc` in order to use the chunk from smallbin instead of tcache. `calloc` will then interpret our fake bk pointer as a new entry to put into tcache, which we can see here:
```
gef➤  heap bins
─────────────────────────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7fa8b80 ───────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=8, size=0xa0] count=7  ←  Chunk(addr=0x7fffffffdb00, size=0x0, flags=)  ←  Chunk(addr=0x5555555593e0, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559700, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559660, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x5555555595c0, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559520, size=0xa0, flags=PREV_INUSE)  ←  Chunk(addr=0x555555559480, size=0xa0, flags=PREV_INUSE) 
──────────────────────────────────────────────────────────────────────────────────── Fastbins for arena 0x7ffff7fa8b80 ────────────────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena 'main_arena' ───────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────────────────────── Small Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] small_bins[9]: fw=0x5555555593d0, bk=0x7fffffffdb00
[!] Command 'heap bins small' failed to execute properly, reason: Cannot access memory at address 0x8
──────────────────────────────────────────────────────────────────────────────────── Large Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```

We can see 2 chunks have been inserted into the tcachebin: `Chunk(addr=0x7fffffffdb00, size=0x0, flags=)  ←  Chunk(addr=0x5555555593e0, size=0xa0, flags=PREV_INUSE)`.

At the location of this last fake chunk, we can see that:
```
gef➤  x/10gx 0x7fffffffdb00
0x7fffffffdb00:	0x00005555555593e0	0x0000555555559010  <- fd pointer to next chunk in tcache>
0x7fffffffdb10:	0x00007ffff7fa8c70	0x0000000000000000  <- leak of libc address>
0x7fffffffdb20:	0x0000000000000000	0x0000000000000000
0x7fffffffdb30:	0x0000000000000000	0x0000000000000000
0x7fffffffdb40:	0x0000000000000000	0x0000000000000000
gef➤  x 0x00007ffff7fa8c70
0x7ffff7fa8c70 <main_arena+240>:	0x00007ffff7fa8c60
```

The next allocation will give us a chunk located at the target address.