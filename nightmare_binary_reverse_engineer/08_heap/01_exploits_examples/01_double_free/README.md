# Double free

This exercise seems to be an explanation of a popular exploit with the heap. Unfortunatly recent libcs have protection against it, so I had to try them in a docker container.

Here is the heap's status after copying 3 strings.
```
gefâž¤  x/30g 0x562a4475b000
0x562a4475b000:	0x0000000000000000	0x0000000000000000
0x562a4475b010:	0x0000000000000000	0x0000000000000041  <- headers
0x562a4475b020:	0x3030303030303030	0x0000000000000000  <- "00000000" followed by nulls
0x562a4475b030:	0x0000000000000000	0x0000000000000000
0x562a4475b040:	0x0000000000000000	0x0000000000000000
0x562a4475b050:	0x0000000000000000	0x0000000000000041
0x562a4475b060:	0x3131313131313131	0x0000000000000000  <- "11111111" followed by nulls
0x562a4475b070:	0x0000000000000000	0x0000000000000000
0x562a4475b080:	0x0000000000000000	0x0000000000000000
0x562a4475b090:	0x0000000000000000	0x0000000000000041
0x562a4475b0a0:	0x3232323232323232	0x0000000000000000  <- "22222222" followed by nulls
0x562a4475b0b0:	0x0000000000000000	0x0000000000000000
0x562a4475b0c0:	0x0000000000000000	0x0000000000000000
0x562a4475b0d0:	0x0000000000000000	0x0000000000020f31  <- What is remaining of the heap (I guess)
0x562a4475b0e0:	0x0000000000000000	0x0000000000000000
```

After the first free:
```
0x562a4475b000:	0x0000000000000000	0x0000000000000000
0x562a4475b010:	0x0000000000000000	0x0000000000000041
0x562a4475b020:	0x0000000000000000	0x0000000000000000 <- It's gone !
0x562a4475b030:	0x0000000000000000	0x0000000000000000
0x562a4475b040:	0x0000000000000000	0x0000000000000000
0x562a4475b050:	0x0000000000000000	0x0000000000000041
0x562a4475b060:	0x3131313131313131	0x0000000000000000
0x562a4475b070:	0x0000000000000000	0x0000000000000000
0x562a4475b080:	0x0000000000000000	0x0000000000000000
0x562a4475b090:	0x0000000000000000	0x0000000000000041
0x562a4475b0a0:	0x3232323232323232	0x0000000000000000
0x562a4475b0b0:	0x0000000000000000	0x0000000000000000
0x562a4475b0c0:	0x0000000000000000	0x0000000000000000
0x562a4475b0d0:	0x0000000000000000	0x0000000000020f31
0x562a4475b0e0:	0x0000000000000000	0x0000000000000000
```

Second free to avoid consolidation (we never take the same address ðŸŽµ):
```
gefâž¤  x/30g 0x562a4475b000
0x562a4475b000:	0x0000000000000000	0x0000000000000000
0x562a4475b010:	0x0000000000000000	0x0000000000000041
0x562a4475b020:	0x0000000000000000	0x0000000000000000
0x562a4475b030:	0x0000000000000000	0x0000000000000000
0x562a4475b040:	0x0000000000000000	0x0000000000000000
0x562a4475b050:	0x0000000000000000	0x0000000000000041
0x562a4475b060:	0x0000562a4475b010	0x0000000000000000
0x562a4475b070:	0x0000000000000000	0x0000000000000000
0x562a4475b080:	0x0000000000000000	0x0000000000000000
0x562a4475b090:	0x0000000000000000	0x0000000000000041
0x562a4475b0a0:	0x3232323232323232	0x0000000000000000
0x562a4475b0b0:	0x0000000000000000	0x0000000000000000
0x562a4475b0c0:	0x0000000000000000	0x0000000000000000
0x562a4475b0d0:	0x0000000000000000	0x0000000000020f31
0x562a4475b0e0:	0x0000000000000000	0x0000000000000000
```

Then after the second free:
```
gefâž¤  x/30g 0x562a4475b000
0x562a4475b000:	0x0000000000000000	0x0000000000000000
0x562a4475b010:	0x0000000000000000	0x0000000000000041
0x562a4475b020:	0x0000562a4475b050	0x0000000000000000
0x562a4475b030:	0x0000000000000000	0x0000000000000000
0x562a4475b040:	0x0000000000000000	0x0000000000000000
0x562a4475b050:	0x0000000000000000	0x0000000000000041
0x562a4475b060:	0x0000562a4475b010	0x0000000000000000
0x562a4475b070:	0x0000000000000000	0x0000000000000000
0x562a4475b080:	0x0000000000000000	0x0000000000000000
0x562a4475b090:	0x0000000000000000	0x0000000000000041
0x562a4475b0a0:	0x3232323232323232	0x0000000000000000
0x562a4475b0b0:	0x0000000000000000	0x0000000000000000
0x562a4475b0c0:	0x0000000000000000	0x0000000000000000
0x562a4475b0d0:	0x0000000000000000	0x0000000000020f31
0x562a4475b0e0:	0x0000000000000000	0x0000000000000000
```

The heap after the 3 subsequent allocations:
```
gefâž¤  x/30g 0x562a4475b000
0x562a4475b000:	0x0000000000000000	0x0000000000000000
0x562a4475b010:	0x0000000000000000	0x0000000000000041
0x562a4475b020:	0x3232323232323232	0x0000000000000000
0x562a4475b030:	0x0000000000000000	0x0000000000000000
0x562a4475b040:	0x0000000000000000	0x0000000000000000
0x562a4475b050:	0x0000000000000000	0x0000000000000041
0x562a4475b060:	0x3131313131313131	0x0000000000000000
0x562a4475b070:	0x0000000000000000	0x0000000000000000
0x562a4475b080:	0x0000000000000000	0x0000000000000000
0x562a4475b090:	0x0000000000000000	0x0000000000000041
0x562a4475b0a0:	0x3232323232323232	0x0000000000000000
0x562a4475b0b0:	0x0000000000000000	0x0000000000000000
0x562a4475b0c0:	0x0000000000000000	0x0000000000000000
0x562a4475b0d0:	0x0000000000000000	0x0000000000020f31
0x562a4475b0e0:	0x0000000000000000	0x0000000000000000
```
And the stack:
```
0x00007ffeb75d3f88â”‚+0x0008: 0x0000562a4475b020  â†’  "22222222"  <- pt3
0x00007ffeb75d3f90â”‚+0x0010: 0x0000562a4475b060  â†’  "11111111"  
0x00007ffeb75d3f98â”‚+0x0018: 0x0000562a4475b020  â†’  "22222222"  <- pt5
```
We can see that both pointers point to the same region in the memory.

Then we free pt3:
```
gefâž¤  x/30g 0x562a4475b000
0x562a4475b000:	0x0000000000000000	0x0000000000000000
0x562a4475b010:	0x0000000000000000	0x0000000000000041
0x562a4475b020:	0x0000562a4475b050	0x0000000000000000  <- because pt3 was freed
0x562a4475b030:	0x0000000000000000	0x0000000000000000
0x562a4475b040:	0x0000000000000000	0x0000000000000000
0x562a4475b050:	0x0000000000000000	0x0000000000000041
0x562a4475b060:	0x3131313131313131	0x0000000000000000
0x562a4475b070:	0x0000000000000000	0x0000000000000000
0x562a4475b080:	0x0000000000000000	0x0000000000000000
0x562a4475b090:	0x0000000000000000	0x0000000000000041
0x562a4475b0a0:	0x3232323232323232	0x0000000000000000
0x562a4475b0b0:	0x0000000000000000	0x0000000000000000
0x562a4475b0c0:	0x0000000000000000	0x0000000000000000
0x562a4475b0d0:	0x0000000000000000	0x0000000000020f31
0x562a4475b0e0:	0x0000000000000000	0x0000000000000000
```

Then we write through pt5:
```
gefâž¤  x/30g 0x562a4475b000
0x562a4475b000:	0x0000000000000000	0x0000000000000000
0x562a4475b010:	0x0000000000000000	0x0000000000000041
0x562a4475b020:	0x3832373533393531	0x0000000000000000  <- chunk that should have been freed !
0x562a4475b030:	0x0000000000000000	0x0000000000000000
0x562a4475b040:	0x0000000000000000	0x0000000000000000
0x562a4475b050:	0x0000000000000000	0x0000000000000041
0x562a4475b060:	0x3131313131313131	0x0000000000000000
0x562a4475b070:	0x0000000000000000	0x0000000000000000
0x562a4475b080:	0x0000000000000000	0x0000000000000000
0x562a4475b090:	0x0000000000000000	0x0000000000000041
0x562a4475b0a0:	0x3232323232323232	0x0000000000000000
0x562a4475b0b0:	0x0000000000000000	0x0000000000000000
0x562a4475b0c0:	0x0000000000000000	0x0000000000000000
0x562a4475b0d0:	0x0000000000000000	0x0000000000020f31
0x562a4475b0e0:	0x0000000000000000	0x0000000000000000
```

So I guess double free consists into
* making libc into giving us two pointers to the same memory region
* freeing one (so the memory managament believes it has one more chunk to allocate)
* letting it allocate the memory region to some program controlled section
* overwrite the value with the other pointer we control

BTW, UAF stands for Use After Free.

After some research, I found a repo showing double free example, even with the libc I am using. First it fills the tcachebins. Then it will request some memory that will be given from the tcache. Then it will be the same as with traditionnal double free, with freeing one pointer, then another and finally the first one again. Then with the next malloc we will get twice the same pointer to the same region of the memory !